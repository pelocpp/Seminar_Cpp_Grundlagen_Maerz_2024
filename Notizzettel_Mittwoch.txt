==============

C++ Grundlagen

Guten Morgen

Mittwoch

Peter Loos 

https://github.com/pelocpp

// ==========================================

Dynamische Speicherverwaltung:

A)  new, delete


B) “Rule of Three”: Kopierkonstruktor, Wertzuweisungsoperator und Destruktor


// ==========================================

int* pArray = new int[10];

-------------------------------------
C#:
int[] numbers = new int[10];

Feature: numbers.length ==> Länge 
-------------------------------------


// ==========================================

C++ ist eine Sprache mit

Value-Semantik    (statisch, Stack)

Pointer-Semantik  (dynamisch, Halde)

Syntax:

Value-Semantik      Zugriff:  Punkt-Operator .

Pointer-Semantik    Zugriff:  Punkt-Operator ->

// ==========================================

Geht eine Wertzuweisung von Objekten in C++:

C#: 

    DynamicArray array1 = new DynamicArray(3);
    array1.fill(10);
    array1.print();

    DynamicArray array2 = new DynamicArray(3);
    array2.fill(20);
    array2.print();

    // Wertzuweisung von Objekten // Wertzuweisung von Referenzen
    array1 = array2;

    // Kopierkontruktor:
    // Keine wirkliche Analogie zu C#
    // kopieren in C#: interface ICloneable


// ==========================================


C#:

Classes are reference types, allocated on the heap and garbage-collected.

Structs are value types allocated on the stack.

Size, Point, struct (Value), int, double

----------------------

C++:

Classes are either pointer types or value types.

Pointer types are allocated on the heap and released with delete.

Value types are allocated on the stack and released, when the function goes out of scope.

// ==========================================



Wann Referenzen

Wann Pointer

=============================================

Hinweis:

Die Schreibweise

pArray[index]

wird abgebildet auf

*(pArray + index)

=======================================================

new, delete

Interessanter:

class Container

  == Daten
  == dynamisch (new, delete)

=======================================================

C#:

int n;

...

int numbers[n];   // dynamisch

Geht in C++ nicht:

int numbers[10];   // konstant

=======================================================

Übung:

DynamicArray

DynamicArray array (100);

....

Länge 10

array.resize (50);

// oder

array.resize (200);


------------------------------------------------

100 auf 90 oder 80 runtergehen .... % Werte


alloc // new : Speicher anlegen

realloc ( aktuellenZeiger, neue Länge  )

------------------------------------------------

Geht das auch einfacher ??????????????????

Ja:

Wie:

Indem ich vorgefertige Klassen aus der Standard Bibliothek (STL) verwende.

------------------------------------------------

Fragmentierung in C++ und C#:

Freispeicherbereiche gibt es mehrere:

Arena // Arenen

Wie geht das in C#:

a) Ich habe Referenzen

b) GC - Garbage Collection

c) Wie erfolgt die Freigabe?? Wie in C++

d) Dann ginge die Defragmentierung NICHT !!!

Truth in C#:

Eine Referenz in C# ist ein DOPPELTER ZEIGER.

DOPPELTE INDIREKTION.

// ====================================================

Beispiel einer Ausführung einer Wertzuweisung:

array1:  len = 3
         data = d70 // aa0

array2:  len = 3
         data = aa0

